Η απλή προστακτική γλώσσα που χρησιμοποιείται για την περιγραφή της συνάρτησης είναι η εξής:

C  := skip
    | i:=E
    | C0;C1
    | while B do C
    | if B then C0 else C1

Ο αρχικός κώδικας της συνάρτησης είναι:

#define <stdbool.h>

#define MAXV 1000000

int findDouble(int N, int a[]) {
    bool f[MAXV];
    for (int i=1; i<=MAXV; ++i) f[i-1] = false;
    for(int i=0; i<N; ++i) if (f[a[i]-1]) return a[i]; else f[a[i]-1] = true;
    return 0;
}

Θερωρούμε r το αποτέλεσμα της συνάρτησης.
Θέλουμε να αποδείξουμε πως το r!=0 αν και μόνο αν υπάρχουν δύο στοιχεία του πίνακα a[i],a[j] για τα οποία ισχύει:
a[x]=a[y]=r με x!=y. Θα ονομάσουμε P1 την συνθήκη αυτή.

Εφόσον η συνάρτηση αποτελείται από μια δήλωση και 2 for loops μπορούμε να είμαστε σίγουροι πως τερματίζει σε κάθε περίπτωση, αφού τα for loops εκτελούν πεπερασμένες επαναλήψεις.
Θεωρούμε το πρόγραμμα ως μια σειρά σύνθετων εντολών (κανόνας C0;C1) της γλώσσας C που ορίσαμε προηγουμένως.

{P1} i:=1; {P1 ^ i=1}
Η ανάθεση απλώς προσθέτει την συνθήκη i=1 στην ήδη υπάρχουσα.

{P1 ^ i=1} while (i<=MAXV) do (f[i-1]:=false; i:=i+1); {P1 ^ f[i]=false}
Λόγω του κανόνα του while στο τέλος του βρόχου η συνθήκη i<=MAXV δεν ισχύει πια

{P1 ^ f[i]=false} i:=0; {P1 ^ f[i]=false ^ i=0}

while (i<N) do (if (f[a[i]-1]) then r:=a[i] else f[a[i]-1]:=true );
Μέσα στο while έχουμε μια εντολή if.
Γνωρίζουμε πως έχουμε δύο διαφορετικά στοιχεία του πίνακα a που είναι ίσα με r. Όταν στο βρόχο βρούμε αυτό με το μικρότερο index (έστω το x).

r:=0 {r=0}