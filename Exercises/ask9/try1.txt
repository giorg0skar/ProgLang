Η απλή προστακτική γλώσσα που θα χρησιμοποιηθεί για την περιγραφή της συνάρτησης είναι η εξής:

C  := skip
    | i:=E
    | C0;C1
    | while B do C
    | if B then C0 else C1

Ο αρχικός κώδικας της συνάρτησης είναι:

#define <stdbool.h>

#define MAXV 1000000

int findDouble(int N, int a[]) {
    bool f[MAXV];
    for (int i=1; i<=MAXV; ++i) f[i-1] = false;
    for(int i=0; i<N; ++i) if (f[a[i]-1]) return a[i]; else f[a[i]-1] = true;
    return 0;
}

Θερωρούμε r το αποτέλεσμα της συνάρτησης.
Θέλουμε να αποδείξουμε πως το r!=0 αν και μόνο αν υπάρχουν δύο στοιχεία του πίνακα a[i],a[j] για τα οποία ισχύει:
a[x]=a[y]=r με x!=y. Θα ονομάσουμε P1 την συνθήκη αυτή.

Εφόσον η συνάρτηση αποτελείται από μια δήλωση και 2 for loops μπορούμε να είμαστε σίγουροι πως τερματίζει σε κάθε περίπτωση, αφού τα for loops εκτελούν πεπερασμένες επαναλήψεις.
Θεωρούμε το πρόγραμμα ως μια σειρά σύνθετων εντολών (κανόνας C0;C1) της γλώσσας C που ορίσαμε προηγουμένως.

Η παραπάνω συνάρτηση σε C γράφεται στη δικη μας γλώσσα ως η σύνθεση των παρακάτω εντολών:

i:=1;
while (i<=MAXV) do (f[i-1]:=false; i:=i+1);
i:=0;
flag:=false;
while (i<N) do ((if (f[a[i]-1] && flag==false) then r:=a[i]; flag:=true else f[a[i]-1]:=true ); i:=i+1);
if (flag==false) then r:=0 else skip

Ξεκινώντας την εκτέλεση του προγράμματος με προσυνθήκη την P1, η εκτέλεση θα είναι ως εξής:

{P1} i:=1; {P1 ^ i=1}
Η ανάθεση απλώς προσθέτει την συνθήκη i=1 στην ήδη υπάρχουσα.

{P1 ^ i=1} while (i<=MAXV) do (f[i-1]:=false; i:=i+1); {P1 ^ f[i]=false}
Λόγω του κανόνα του while στο τέλος του βρόχου η συνθήκη i<=MAXV δεν ισχύει πια

{P1 ^ f[i]=false} i:=0; {P1 ^ f[i]=false ^ i=0}
{P1 ^ f[i]=false ^ i=0} flag:=false {P1 ^ f[i]=false ^ i=0 ^ flag=false}
Η μεταβλητή flag χρησιμοποιείται προκειμένου να μπορέσουμε να αποδώσουμε το return στην γλώσσα που χρησιμοποιούμε.

{P1 ^ f[i]=false ^ i=0 ^ flag=false} while (i<N && !flag) do ((if (f[a[i]-1]) then r:=a[i]; flag:=true else f[a[i]-1]:=true ); i:=i+1);

Μέσα στο while έχουμε μια εντολή if.
Γνωρίζουμε πως έχουμε δύο διαφορετικά στοιχεία του πίνακα a που είναι ίσα με r (a[x] και a[y]). Όταν στο βρόχο βρούμε αυτό με το μικρότερο index 
(θεωρούμε χωρίς βλάβη της γενικότητας ότι είναι το x) τότε εφόσον η συνθήκη f[r-1] δεν ικανοποιείται θα γίνει η ανάθεση f[r-1]:=true. Επειδή γνωρίζουμε 
ότι πρέπει να ικανοποιηθεί η συνθήκη P1 προκειμένου να τερματίσει το πρόγραμμα, γνωρίζουμε ότι υπάρχει και δεύτερο στοιχείο το οποίο ισούται με r, το οποίο 
από παραδοχή θεωρούμε πως είναι το a[y] (αφού θεωρήσαμε πως x < y). Άρα στην επανάληψη που θα έχουμε i=y η συνθήκη f[r-1] θα ικανοποιείται, αφού προηγουμένως είχαμε 
κάνει την ανάθεση f[r-1]:=true, και θα γίνουν οι αναθέσεις r:=a[i] και flag:=true. Εφόσον το flag είναι true το πρόγραμμα βγαίνει από το while loop.

if (flag==false) then r:=0 else skip {P1 ^ r > 0}
Αν το flag είναι false τότε σημαίνει πως δε βρέθηκαν δύο στοιχεία του πίνακα με την ίδια τιμή και η τιμή επιστροφής r θα είναι 0, αλλιώς εκτελείται απλώς ένα skip 
και η τιμή του r παραμένει ίδια με το a[y] όπως είχε γίνει στην ανάθεση στο προηγούμενο while loop. 

Εφόσον στην εκτέλεση μας ισχύει η συνθήκη a[x]=a[y]=r με x!=y για δύο στοιχεία του πίνακα a τότε το flag θα είναι σίγουρα true όπως φαίνεται από την παραπάνω εκτέλεση, 
οπότε η τιμή του r θα είναι ίση με r=a[x]=a[y] και γνωρίζουμε ότι τα στοιχεία του πίνακα έχουν τιμές στο διάστημα [1,1000000] άρα είναι σίγουρα διαφορετικά του μηδενός.
Άρα τελικά αν ισχύει η συνθήκη P1 θα έχουμε r!=0.
Αν γνωρίζουμε ότι η συνθήκη αυτή δεν ικανοποιείται (δηλαδή δεν υπάρχουν δύο διαφορετικά στοιχεία του a με ίδια τιμή) τότε η εκτέλεση του προγράμματος παραμένει ίδια 
μέχρι το πρώτο while loop. Στο δεύτερο δε θα ικανοποιηθεί ποτέ η συνθήκη f[a[i]-1] αφού δε θα έχουμε δύο στοιχεία με διαφορετικό index και ίδια τιμή. Άρα εφόσον το flag 
δε γίνεται ποτέ ίσο με true στην εκτέλεση του 
if (flag==false) r:=0 else skip
τώρα θα ικανοποιηθεί η συνθήκη και θα γίνει η ανάθεση r:=0.

Άρα το αποτέλεσμα της συνάρτησης r θα είναι διάφορο του 0 αν και μόνο αν ισχύει η συνθήκη a[x]=a[y], x!=y στην αρχή της εκτέλεσης του προγράμματος.